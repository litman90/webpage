{
  "hash": "b61007d6fb8ededcf66f71ba97328696",
  "result": {
    "markdown": "---\ntitle: \"Matlab list_files\"\ndate: 2018-04-24\ntags: [\"learning\", \"ideas\", \"R\", \"Matlab\"]\n---\n\n\nMy preferred programing language is R. But, for many purposes, I find myself in need of a Graphical User Interface (GUI). Thus, I experienced a forceful transition to Matlab. Let's be honest, Matlab can do powerful things, and it's a great language to attempt to dominate (note to self: learn Python![^notetoself]). Still, I find myself over and over thinking in `R` mode. Something along the lines of:\n\n[^notetoself]: In 2023, having learned Python, I celebrate that my Matlab days are long over. That being said, I ended up writing an `rlist_files` package for Python due to fighting against `os` and `Path` libraries. You can find it [here](https://github.com/matiasandina/rlist_files).\n\n> Gimme all the files in folder with xyz...\n\nCan be easily accomplished in `R` with `list.files()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.files(...)\n```\n:::\n\n\nThis command can handle many many options, with `pattern` being among my favorite. More importantly, this command returns a useful `character` vector. No extra dots, no list of lists, no array. Just, useful. On the other hand, Matlab has `dir` and `ls` both of which are not satisfactory.   \n\n\n::: {.cell}\n\n```{.octave .cell-code}\ndir\n\n.                                                      \n..                                    \nsomething.m                            \nsomething_else.m                               \nLookHere.m\n\n```\n:::\n\n\nYes... Matlab's version can also handle some form of regular expression matching. But, mind the dots and the structure! Matlab's `dir` has a ton of things on it.  \n\n\n::: {.cell}\n\n```{.octave .cell-code}\n>> q = dir\n\nq = \n\n  20×1 struct array with fields:\n\n    name\n    folder\n    date\n    bytes\n    isdir\n    datenum\n```\n:::\n\n\nMatlab `ls` function is also full of deadly traps.  \n\n\n::: {.cell}\n\n```{.octave .cell-code}\nqq = ls\n\nqq =\n\n  20×28 char array\n\n    '.                           '\n    '..                          '\n    'many_things_here.ext        '\n\n```\n:::\n\n\n\n## The solution\n\nI found myself fighting for a character vector or array (`nx1`) that I could feed into a function/loop/whatever.  \n\nThus, after many many many times fighting against classes, with functions that expect `char` instead of `string`, or `cell`, or `whatever`, I decided to create something that resembles (at least partially) the functionality I was looking for. It's not perfect. Please enlighten me with a better approach. For now, I will be using `list_files.m`. Wanna use it? Be my guest, see below:\n\n\n::: {.cell}\n\n```{.octave .cell-code  code-fold=\"true\" code-summary=\"Show Matlab Code\"}\n% The idea of this function is to have something that works to list files\n% Matlab has too many weird things with dir/patterns/etc...\n% It could be slow if calling in a BIG dir and then subsetting\n% Otherwise it should work pretty fast\n\nfunction filenames = list_files(varargin)\n\n% Open input parser\np = inputParser();\n\n% Add possible values\naddOptional(p, 'Interactive', true, @islogical)\naddOptional(p, 'Dirname', '0', @ischar)\naddOptional(p, 'Pattern', {'.'}, @iscell)\naddOptional(p, 'FullPath', false, @islogical)\n\n\n% parse\nparse(p, varargin{:});\n\n% retrieve things from parser\nInteractive = p.Results.Interactive;\nDirname = p.Results.Dirname;\nPattern = p.Results.Pattern;\nFullPath = p.Results.FullPath;\n\n\n%% Dirname goes first\n% If we didn't provide a Dirname, both defaults will hold\n% If we provided a Dirname, we will read from there\n\nif (Interactive && string(Dirname) == '0')\n\n    dirname = uigetdir();\n\nelse\n    \n    dirname = Dirname;\n    \nend\n\n\nif ~isdir(dirname)\n    error('Dirname not valid, check dirname provided is character and exists.')\nend\n\n% actually call dir\n    d=dir(dirname);\n% Remove the dots matlab puts to things\n    d=d(~ismember({d.name},{'.','..'}));\n\n    % Get filenames\n    % Output as an mx1 cell\n    \n    filenames = {d.name}';\n\n        \n%% Subset by pattern\n    \n    default_pattern = string(Pattern) == '.';\n\n    if (~default_pattern) % non default case\n    \n    % join cell patterns separated by the 'or' regular expression\n    query_expression = strjoin(Pattern, '|');\n    \n    %  Subset the patterns\n    filenames = filenames(~cellfun(@isempty,regexp(filenames, query_expression)));\n    end\n    \n    % By default we return just the name\n    % If you want the full path, call it!\n    % it currently works only for 1 folder\n    % Recursive = TRUE will be super nice!\n    \n    if FullPath\n    filenames = fullfile(unique({d.folder}), filenames);\n    end\nend\n\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}