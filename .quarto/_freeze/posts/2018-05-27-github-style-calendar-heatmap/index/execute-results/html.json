{
  "hash": "dd82c14ebcd0b4bb965945552d1966b0",
  "result": {
    "markdown": "---\ntitle: \"Github style calendar heatmaps\"\ndate: 2018-05-27\ncategories: [\"research\", \"design\", \"R\"]\nexecute: \n  echo: true\ncode-fold: true\ncode-summary: \"Show the code\"\n---\n\n\n## The Commit Heatmap\n\nI like how the commit heatmap looks in Github. I wanted to play with something that could be plotted that way. I've seen some beautiful things done in `d3` and javascript. But, of course, I wanted to make it in `R`. Turns out a bunch of other people have great ideas for how to go about it. Thus, I'm borrowing heavily from them[^1].\n\n[^1]: Great resources [here](https://vuorre.netlify.com/post/2016/2016-03-24-github-waffle-plot/), [and here](http://ethen8181.github.io/Business-Analytics/articles/calendar_heatmaps/calendar_heatmaps.html)\n\n## Loading packages\n\nWe will need a few packages to generate this plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(viridis)  # Color palette\nlibrary(ggthemes) # theme tufte\n```\n:::\n\n\n## The data\n\nLet's generate a `data.frame` for May 2018. We want the `date` as `datetime` and we also want to extract values from that date (month, year, week, ...).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# choose dates\nstart_date <- ymd(\"2018-05-01\")\nend_date <- ymd(\"2018-05-31\")\n\nd <- tibble::tibble(\n    date = seq(start_date, end_date, by = \"days\"),\n    month = month(date),\n    year = format(date, \"%Y\"),\n    week = as.integer(format(date, \"%W\")) + 1,  # Week starts at 1\n    day = factor(weekdays(date, T), \n                 levels = rev(c(\"Mon\", \"Tue\", \"Wed\", \"Thu\",\n                                \"Fri\", \"Sat\", \"Sun\"))))\n```\n:::\n\n\nThis is how the data we generated looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  date       month year   week day  \n  <date>     <dbl> <chr> <dbl> <fct>\n1 2018-05-01     5 2018     19 Tue  \n2 2018-05-02     5 2018     19 Wed  \n3 2018-05-03     5 2018     19 Thu  \n4 2018-05-04     5 2018     19 Fri  \n5 2018-05-05     5 2018     19 Sat  \n6 2018-05-06     5 2018     19 Sun  \n```\n:::\n:::\n\n\nNow, let's assume I registered some events in my life and that my data looks something like: A date column `date`, and the number of events that happened on a particular date (`n`).\n\n\n::: {.cell}\n\n:::\n\n\nAgain, here's how the data looks like.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 13 × 2\n   date           n\n   <date>     <int>\n 1 2018-05-15     1\n 2 2018-05-16     1\n 3 2018-05-17     1\n 4 2018-05-18     2\n 5 2018-05-19     4\n 6 2018-05-20     2\n 7 2018-05-21     2\n 8 2018-05-22     2\n 9 2018-05-23     2\n10 2018-05-24     5\n11 2018-05-25     2\n12 2018-05-26     1\n13 2018-05-27     4\n```\n:::\n:::\n\n\nI can join both `data.frames` and visualize!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_plot <- d %>% left_join(df, by = \"date\") \n\ndf_plot %>%\n  mutate(n=ifelse(is.na(n), 0, n)) %>% ## Fill the NAs with zeros\n  ggplot(aes(date, n)) +\n  geom_line(lwd=0.7)+\n  geom_point(size=2, shape=21, fill=\"black\", colour=\"white\", stroke=2)+\n    theme_classic() +\n  theme(panel.background = element_rect(colour = \"black\"))+\n  ylab(\"Number of events\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/line-plot-1.png){width=672}\n:::\n:::\n\n\nMy goal is not to analyze long term trends like seasonality. Thus, this plot is rather unremarkable. Not only because it is a small toy-like dataset, but because it fails to inform calendar information. Let's try to make it better!\n\n## Abstracting into functions\n\nA good way of improving the procedure is to abstract things into a function we can call `calendar_plot()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalendar_plot <- function(data, color.scale = \"viridis\",\n                          viridis.pal = \"D\", dir = 1){\n  \n  p <- ggplot(data, aes(x = week, y = day, fill = n)) +\n    geom_tile(color = \"white\", size = 0.8) +\n    facet_wrap(\"year\", ncol = 1) +\n    theme_tufte() +\n    theme(axis.ticks = element_blank(),\n          legend.position = \"bottom\",\n          legend.key.width = unit(1, \"cm\"),\n          strip.text = element_text(hjust = 0.01,\n                                    face = \"bold\", size = 12),\n          text = element_text(size=16)) + \n    ylab(\"\")\n  \n  \n  \n  # Let's add more than one possible pallete. Default keeps being viridis\n  # Add case switch? or add 'none' for user to define their own ?\n  \n  if(color.scale==\"viridis\"){\n    \n    \n    p <- p + scale_fill_viridis(name=\"Number of Events\", \n                                # Variable color palette\n                                option = viridis.pal,  \n                                # Variable color direction\n                                direction = dir,  \n                                na.value = \"grey93\",\n                                limits = c(1, max(data$n)))\n    \n  } else if(color.scale == 'greens') {\n    \n    p <- p + \n      scale_fill_gradient(name=\"Number of Events\",\n                          low=\"lightyellow2\", \n                          high=\"darkgreen\", \n                          na.value = \"grey93\")\n  } else{\n    \n    error(\"Accepted color.scale are 'viridis' and 'greens'\")\n    \n  }\n  \n  \n  ## x axis control of labels\n  \n  \n  num_months <- length(unique(data$month))\n  \n  if(num_months > 1){\n    \n    p <- p + scale_x_continuous(\n      expand = c(0, 0),\n      breaks = seq(1, 52, length = 12),\n      labels = c(\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                 \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"))\n    \n  } else {\n    \n    # do nothing\n    \n    p <- p + xlab(\"Week Number.\")\n    \n  }\n  \n  \n  \n  print(p)\n}\n```\n:::\n\n\nWe can use `calendar_plot()` function now to make a plot in *calendar-like* shape. It is easier to see the data, even with such as small dataset. Below there are two color scale representations of the same data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalendar_plot(df_plot, 'greens')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/calendar-plot-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncalendar_plot(df_plot, viridis.pal = \"B\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/calendar-plot-2.png){width=672}\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## Update\n\nI was curious about how data would look like for a longer span. Here's the data for a longer time interval.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncalendar_plot(df_plot)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/update-plot-1.png){width=672}\n:::\n:::\n\n\nBy no means this is a perfect function and is far from tested. For example, when I did this update, I realized that my `calendar_plot()` function should handle internally the creation of the `data.frame` named `d` that serves as a placeholder. I guess that will happen in a following update `:)`.\n\n------------------------------------------------------------------------\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}